---
name: 'Adding Server-Side Logic'
route: '/guides/adding-server-side-logic'
menu: Guides
---

# Adding Server-Side Logic

One of the best use-cases for FABs, once your project [can produce a working FAB](/guides/getting-started), is to add small amounts of server-side logic to a mostly-static build, _without needing to change how you package & deploy your application_. This guide shows you how.

### An aside: "Static" hosting isn't really static

Something that's often overlooked when choosing a hosting provider for a "static" project (e.g. client-side rendered or JAMstack) is that there is a whole host of server-side concerns that don't neatly fit into uploading a directory full of HTML files. These invariably end up being captured as vendor-specific config files, such as those for [Netlify](https://docs.netlify.com/configure-builds/file-based-configuration), [Vercel](https://vercel.com/docs/configuration) or [Firebase](https://firebase.google.com/docs/hosting/full-config); or configuration settings in the platform itself, such as for [AWS S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/HowDoIWebsiteConfiguration.html).

For example, proxying requests that come in on `/api/*` to `api.example.com/*` would be done using the following section in your `netlify.toml` file:

```toml
[[redirects]]
  from = "/api/*"
  to = "https://api.example.com/:splat"
  status = 200
  force = true
```

While several of the server-side behaviours described here will be possible with the "static" host you're currently using, FAB offers a different approach: by standardising the inclusion of server-side JavaScript, we can now use _code over configuration_, and have a truly portable frontend application artefact, even if we're "only serving static HTML"!

## Proxying an API

Following on from the previous example, we can see how much more general the FAB approach is to solving this problem:

```js
// proxy-api.js
export default Runtime => {
  Runtime.on('/api/:route(.*)', ({ params }) =>
    fetch(`https://api.example.com/${params.route}`)
  )
}
```

## Making a simple server-side request on a URL

```ts
// TypeScript server-side components work without transpilation
import { FABRuntime } from '@fab/core'

export default (Runtime: FABRuntime) => {
  Runtime.on('/geolocate', async () => {
    const geo_response = await fetch('http://ip-api.com/json')
    const geo_json = await geo_response.json()
    const { country, regionName, city } = geo_json
    return new Response(
      `This request is being served from ${city} in ${regionName}, ${country}.`,
      {
        headers: {
          'Content-Type': 'text/plain',
        },
      }
    )
  })
}
```

## Attaching a BUNDLE_ID header to all outgoing responses

```ts
export default Runtime => {
  Runtime.interceptResponse(async (response) => {
    response.headers.set('X-FAB-ID', Runtime.context.bundle_id)
    return response
  })
}
```
