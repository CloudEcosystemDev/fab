---
name: 'Plugins'
route: '/kb/plugins'
menu: Knowledge Base
---

# Plugins

What makes FAB plugins different to other JS web tooling is that plugins are can be invoked during _both_ compile time & at runtime. What this means is that a plugin can read/manipulate a FAB as it's being constructed, and _also_ inject the server-side code needed. This is best demonstrated with a simple example:

```js
// server/old-blog-url-format.js

export const build = async (args, proto_fab) => {
  // Attach an object to proto_fab.metadata, which is serialised
  // and passed to your runtime as the second argument
  proto_fab.metadata.blog_rewrites = {}

  for (const filename of proto_fab.files.keys()) {
    // Look for anything looking like /blog/123-new-post-format
    const new_blog_format = filename.match(/^\/blog\/(\d+)/)
    if (new_blog_format) {
      const blog_id = new_blog_format[1]
      // Make a record that this `blog_id` now lives at `filename`
      proto_fab.metadata.blog_rewrites[blog_id] = filename
    }
  }
}

export const runtime = (args, metadata) => {
  // Runtime functions are synchronous in order to perform any
  // setup needed.
  const { blog_rewrites } = metadata

  // They return an async function that can intervene on any request
  return async ({ request, settings, url }) => {
    // Only respond on request for the old URL pattern /articles/123
    const old_blog_format = url.pathname.match(/^\/articles\/(\d+)/)
    if (!old_blog_format) return

    // Same as before, pull the `blog_id` off the URL
    const blog_id = old_blog_format[1]
    const new_blog_url = blog_rewrites[blog_id]
    if (!new_blog_url) {
      // If that `blog_id` doesn't exist, return a 404
      return new Response(null, { status: 404 })
    } else {
      // Otherwise return a 301 Moved Permanently
      return new Response(null, {
        status: 301,
        headers: {
          Location: new_blog_url,
        },
      })
    }
  }
}
```

## Build-time vs Run-time

Though you _can_ use a single file to export both a `build` and `runtime` export, for anything more sophisticated you're going to want to have separate files. This is because the two commands run at different times, in quite different environments. `build` is called by the CLI, so has access to the full NodeJS ecosystem of tools, and direct access to the filesystem. `runtime`, on the other hand, is **compiled into the FAB itself**. This means it, and its dependencies, _need to be compatible with the [FAB Runtime Environment](/kb/fab-runtime-environment)_, which is pure JS, no NodeJS at all.

The FAB plugins, then, use their `main` export of `index.js` to export the `build` function, and also publish a `/runtime.js` file.

So, for a plugin config like:

```json5
{
  plugins: {
    '@fab/some-plugin': { /* ... */ }
  }
}
```

First, we try to resolve `@fab/some-plugin/runtime`, and if it's found, it's compiled using Rollup and expected to contain a `runtime` export.

